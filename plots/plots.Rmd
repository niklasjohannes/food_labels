---
title: "Plots"
author: "Niklas Johannes"
date: "2019-11-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE,
                      cache = TRUE)
```

In this file, I produce the graphs for the analysis section.
I start with loading the libraries we need, plus functions.

Note: To get the same font for the graphs, you will probably need to call the `font_import` command from the `extrafont` package.
The colors I selected from [here](https://www.datanovia.com/en/blog/ggplot-colors-best-tricks-you-will-love/#use-a-colorblind-friendly-palette).
```{r load_libraries}
# pacman makes it easier to load and install packages
if (!requireNamespace("pacman"))
  install.packages("pacman")

library(pacman)

p_load(
  Rmisc,
  tidyverse,
  ggthemes,
  here,
  cowplot,
  effects,
  extrafont
)

loadfonts(device = "win")

set.seed(42)

options(contrasts = c("contr.sum", "contr.poly"))
```

```{r functions}
### FUNCTION 1 ###
# raincloud plot function from https://github.com/RainCloudPlots/RainCloudPlots/blob/master/tutorial_R/R_rainclouds.R
# Defining the geom_flat_violin function ----
# Note: the below code modifies the
# existing github page by removing a parenthesis in line 50

"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomFlatViolin,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      trim = trim,
      scale = scale,
      ...
    )
  )
}

#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @export
GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
    setup_data = function(data, params) {
      data$width <- data$width %||%
        params$width %||% (resolution(data$x, FALSE) * 0.9)

      # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
      data %>%
        group_by(group) %>%
        mutate(
          ymin = min(y),
          ymax = max(y),
          xmin = x,
          xmax = x + width / 2
        )
    },

    draw_group = function(data, panel_scales, coord) {
      # Find the points for the line to go all the way around
      data <- transform(data,
        xminv = x,
        xmaxv = x + violinwidth * (xmax - x)
      )

      # Make sure it's sorted properly to draw the outline
      newdata <- rbind(
        plyr::arrange(transform(data, x = xminv), y),
        plyr::arrange(transform(data, x = xmaxv), -y)
      )

      # Close the polygon: set first and last point the same
      # Needed for coord_polar and such
      newdata <- rbind(newdata, newdata[1, ])

      ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
    },

    draw_key = draw_key_polygon,

    default_aes = aes(
      weight = 1, colour = "grey20", fill = "white", size = 0.5,
      alpha = NA, linetype = "solid"
    ),

    required_aes = c("x", "y")
  )

### FUNCTION 2###
# function for a raincloud plot with different variables on the y-axis
rc_plot <- function(
  df,
  variable,
  xgroup_n,
  xgroup,
  ylab
) {

    # first get summary statistics plus CI
  summary_stats <-
    summarySE(
      data = df,
      measurevar = variable,
      groupvars = "food_type"
    ) %>% 
    mutate( # recreate "numeric" factor (see description raincloud plots)
      food_type_n = case_when(
      food_type == "meat_based" ~ 1,
      food_type == "vegetarian" ~ 2,
      food_type =="plant_based" ~ 3
      ),
      food_type_n = as.factor(food_type_n)
    )
  
  # get plot
  p <-
    ggplot(
      study1,
      aes_string(
        x = xgroup_n,
        y = variable,
        fill = xgroup
      )
    ) +
    geom_flat_violin(position = position_nudge(x = 0.05, # move the cloud a bit to the right
                                               y = 0),
                     adjust = 1.5,
                     trim = FALSE,
                     alpha = 0.5,
                     color = NA) +
    geom_point(aes_string(x = df %>% pull(xgroup_n) %>% as.numeric() -.15, # transfer the factor to number so that I can move the rain to the left with the -.2
                   color = xgroup,
                   y = variable),
               position = position_jitter(width = .10),
               size = 1.2,
               alpha = 0.4) +
    geom_point( # the mean
      data = summary_stats,
      aes_string(
        x = summary_stats %>% pull(xgroup_n) %>% as.numeric() -.25, # same as above, moving it a bit to the left to be right between cloud and rain
        y = variable,
        color = xgroup
      ),
      position = position_nudge(.25),
      size = 3
    ) +
    geom_errorbar( # error bars
      data = summary_stats,
      aes(
        x = get(xgroup_n) %>% as.numeric() - .25,
        y = get(variable),
        ymin = get(variable) - ci,
        ymax = get(variable) + ci,
        color = get(xgroup)
      ),
      position = position_nudge(.25),
      width = 0.00,
      size = 0.8
    ) +
    ylim(c(-.002,1)) + # to not cut off points with jitter
    ylab(ylab) +
    xlab("Food Type") +
    scale_x_discrete(labels = c("Meat-based", "Vegetarian","Plant-based")) + # rename the x axis after transforming it to numeric earlier
    scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
    scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
    theme_cowplot() +
    theme(
      text = element_text(
        family="Century Gothic" # change font
      ),
      legend.position = "none" # remove legend
    )
  
  return(p)
}

### FUNCTION 3 ###
# this function gets effects from mixed effects models and plots them

# helper function that get the effects at 5000 values of the predictor and turns them into a tibble
get_effects <-
  function(
    interaction_term,
    lmer_model,
    n_levels,
    factor_to_recode
  ) {
    
    # get estimates
    estimates <- 
      effect(
        interaction_term,
        lmer_model,
        xlevels = n_levels
      )
    
    # turn estimates into a tibble, so I can access them with ggplot later
    effects_tibble <-
      as_tibble(estimates)
    
    if( # recode depending on which grouping factor
      factor_to_recode == "food_type"
    ){
      effects_tibble <-
        effects_tibble %>% 
        mutate( # recode values for the legend later
        food_type = recode(
          food_type,
          "plant_based" = "Plant-based",
          "meat_based" = "Meat-based"
        )
      )
    }
    
    else{
      effects_tibble <-
        effects_tibble %>% 
        mutate( # recode values for the legend later
        label_type = recode(
          label_type,
          "control" = "Control",
          "enhanced" = "Enhanced"
        )
      )
    }
      
    
    return(effects_tibble)
  }

# plot function for line plots
interaction_plot <-
  function(
    dat,
    predictor,
    outcome,
    group_by,
    y_lab,
    x_lab,
    legend_title
  ){
    line_plot <-
    ggplot(
      dat, 
      aes_string(
        x = predictor, # continuous predictor
        y = outcome, # the fitted outcome
        color = group_by,
        fill = group_by
        )
      ) +
      geom_line() + # fit a line, which should be linear because we have 5000 data points
      geom_ribbon( # create the CI around the line from the upper and lower CI in the effects tibble
        aes(
          ymin = lower,
          ymax = upper,
          color = NA # remove borders
        ),
        alpha = 0.2
      ) +
      ylim(c(0, 100)) +
      ylab(y_lab) +
      xlab(x_lab) +
      labs(color = legend_title,
           fill = legend_title) + # otherwise I get two legends)
      theme_cowplot() +
      scale_color_manual(values = c("#009E73", "#D55E00")) +
      scale_fill_manual(values = c("#009E73", "#D55E00")) +
      theme(
        text = element_text(
          family="Century Gothic", # change font
          size = 20
        ), 
        strip.background.x = element_blank(),
        axis.text.x = element_text(
          size = 17
        ),
        legend.title = element_text(
          size = 17
        ),
        legend.text = element_text(
          size = 17
        )
      ) 
  }
```

# 1. Study 1

## 1.1 Load data
First, I load the analysis file from Study 1.
I saved it at the end of `analysis_report_study1.Rmd`.
```{r get_data_study1}
study1 <- read_csv(here("data", "study1", "analysis_file.csv"))

# reintroduce factors
study1 <-
  study1 %>%
  mutate_at(
    vars(food_id:supermarket),
    list(~ as.factor(.))
  )
```

For the plot, I rename `vegan` to `plant-based` to be consistent with study 2, and also reorder the factor to go from meat to vegetarian to plant-based.
```{r reorder_study1}
study1 <-
  study1 %>% 
  mutate(
    food_type = fct_recode(
      food_type,
      "plant_based" = "vegan"
    ),
    food_type = fct_relevel(
      food_type,
      "vegetarian",
      after = 1
    )
  )
```


Now on to the producing the raincloud plots for the proportions of feature categories by food type.
To get the points (aka the rain) to fall left of the x-axis mark, the authors recommend to recode the factor on the x-axis to numbers, and then use that number to "move" the points.
```{r factors_to_numbers_study1}
study1 <-
  study1 %>% 
  mutate(
    food_type_n = case_when(
      food_type == "meat_based" ~ 1,
      food_type == "vegetarian" ~ 2,
      food_type =="plant_based" ~ 3
    ),
    food_type_n = as.factor(food_type_n)
  )
```

## 1.2 Raincloud plots

For means with 95%CI, I also need the summary statistics between-subject standard errors.
I'll get those with the `Rmisc` package.
Note that I integrated this part into a function; thus not run.
```{r get_summary_sensory, eval=FALSE}
# then get summary stats
sensory_stats_study1 <-
  summarySE(
    data = study1,
    measurevar = "sensory_proportion",
    groupvars = "food_type"
  ) %>% 
  mutate( # same as above
  food_type_n = case_when(
    food_type == "meat_based" ~ 1,
    food_type == "vegetarian" ~ 2,
    food_type =="plant_based" ~ 3
  ),
  food_type_n = as.factor(food_type_n)
)
```

Next, the raincloud plots.
I followed [this](https://peerj.com/preprints/27137v1/) tutorial paper.
I turned the code below into a function; thus not run.
```{r make_it_rain_study1, eval=FALSE}
rc_plot <-
  ggplot(
    study1,
    aes(
      x = food_type_n,
      y = sensory_proportion,
      fill = food_type,
    )
  ) +
  geom_flat_violin(position = position_nudge(x = 0.05, # move the cloud a bit to the right
                                             y = 0),
                   adjust = 1.5,
                   trim = FALSE,
                   alpha = 0.5,
                   color = NA) +
  geom_point(aes(x = as.numeric(food_type_n)-.15, # transfer the factor to number so that I can move the rain to the left with the -.2
                 color = food_type,
                 y = sensory_proportion),
             position = position_jitter(width = .1),
             size = 1.2,
             alpha = 0.4) +
  geom_point( # the mean
    data = sensory_stats_study1,
    aes(
      x = as.numeric(food_type_n)-.25, # same as above, moving it a bit to the left to be right between cloud and rain
      y = sensory_proportion,
      color = food_type
    ),
    position = position_nudge(.25),
    size = 3
  ) +
  geom_errorbar( # error bars
    data = sensory_stats_study1,
    aes(
      x = as.numeric(food_type_n)-.25,
      y = sensory_proportion,
      ymin = sensory_proportion - ci,
      ymax = sensory_proportion + ci,
      color = food_type
    ),
    position = position_nudge(.25),
    width = 0.02,
    size = 0.8
  ) +
  ylim(c(-.002,1)) + # to not cut off points with jitter
  ylab("Proportion of Sensory Features") +
  xlab("Food Type") +
  scale_x_discrete(labels = c("Meat-based", "Vegetarian","Plant-based")) + # rename the x axis after transforming it to numeric earlier
  scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
  scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic" # change font
    ),
    legend.position = "none"
  )

rc_plot
```

Start with sensory and action features.
```{r sensory_rain}
sensory_plot <-
  rc_plot(study1,
          "sensory_proportion",
          "food_type_n",
          "food_type",
          "Proportion of Sensory Features")

sensory_plot
```

Next the entire category of consumption features.
```{r consumption_rain}
consumption_plot <-
  rc_plot(study1,
          "consumption_proportion",
          "food_type_n",
          "food_type",
          "Proportion of Consumption Situation Features")

consumption_plot
```

And non-consumption features.
```{r non_consumption_rain}
non_consumption_plot <-
  rc_plot(study1,
          "non_consumption_proportion",
          "food_type_n",
          "food_type",
          "Proportion of Non-Consumption Situation Features")

non_consumption_plot
```

And consumption-independent features.
```{r consumption_independent_rain}
situation_independent_plot <-
  rc_plot(study1,
          "situation_independent_proportion",
          "food_type_n",
          "food_type",
          "Proportion of Situation-Independent Features")

situation_independent_plot
```


Alternatively, I'd like to have the three categories shown per food type.
For that purpose, I need to restructure the data (into long format), so I can facet wrap the plots.
Also, I need summary stats, this time with within-subject standard error because there are multiple measurements of proportions per food type.
```{r get_summary_proportion_type}
# turn into long format
study1_long <-
  study1 %>% 
  select(
    food_id,
    food_type,
    supermarket,
    consumption_proportion,
    non_consumption_proportion,
    situation_independent_proportion
  ) %>% 
  # turn into long format
  pivot_longer(
    cols = c(-food_id, -food_type, -supermarket),
    names_to = c("proportion_type", ".value"),
    names_sep = "_(?!.*_)"
  ) %>% 
  mutate( # for raincloud
    proportion_type_n = case_when(
      proportion_type == "consumption" ~ 1,
      proportion_type == "non_consumption" ~ 2,
      proportion_type == "situation_independent" ~ 3
    ),
    proportion_type = as.factor(proportion_type),
    proportion_type = recode(
      proportion_type,
      "consumption" = "Consumption situation",
      "non_consumption" = "Non-consumption situation",
      "situation_independent" = "Situation independent"
    ),
    food_type = recode(
      food_type,
      "meat_based" = "Meat-based",
      "vegetarian" = "Vegetarian",
      "plant_based" = "Plant-based"
    )
  )

summary_stats_study1 <-
  summarySEwithin(
    data = study1_long,
    measurevar = "proportion",
    withinvars = c("proportion_type"),
    betweenvars = c("food_type"),
    idvar = "food_id"
  ) %>% 
  mutate( # for raincloud
    proportion_type_n = case_when(
      proportion_type == "Consumption situation" ~ 1,
      proportion_type == "Non-consumption situation" ~ 2,
      proportion_type == "Situation independent" ~ 3
    ),
    food_type = recode(
      food_type,
      "meat_based" = "Meat-based",
      "vegetarian" = "Vegetarian",
      "plant_based" = "Plant-based"
    )
  )
```

Next the raincloud plot.
```{r make_it_rain_study1_proportion_types}
food_type_plot <-
  ggplot(
    study1_long,
    aes(
      x = proportion_type_n,
      y = proportion,
      fill = proportion_type,
    )
  ) +
  geom_flat_violin(position = position_nudge(x = .1, # move the cloud a bit to the right
                                             y = 0),
                   adjust = 1.5,
                   trim = FALSE,
                   alpha = 0.5,
                   color = NA) +
  geom_point(aes(x = as.numeric(proportion_type_n)-.2, # transfer the factor to number so that I can move the rain to the left with the -
                 color = proportion_type,
                 y = proportion),
             position = position_jitter(width = .1),
             size = 1.2,
             alpha = 0.4) +
  geom_point( # the mean
    data = summary_stats_study1,
    aes(
      x = as.numeric(proportion_type_n)-.25, # same as above, moving it a bit to the left to be right between cloud and rain
      y = proportion,
      color = proportion_type
    ),
    position = position_nudge(.25),
    size = 3
  ) +
  geom_errorbar( # error bars
    data = summary_stats_study1,
    aes(
      x = as.numeric(proportion_type_n)-.25,
      y = proportion,
      ymin = proportion - ci,
      ymax = proportion + ci,
      color = proportion_type
    ),
    position = position_nudge(.25),
    width = 0.00,
    size = 0.8
  ) +
  ylim(c(-.002,1.002)) + # to not cut off points with jitter
  xlab("Food Type") +
  ylab("Proportion") +
  labs(fill = "Proportion Type", # otherwise I get two legends
       color = "Proportion Type") +
  scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
  scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic", # change font
      size = 22
    ),
    legend.title = element_text(
      size = 14
    ),
    legend.text = element_text(
      size = 14
    ),
    strip.background.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  facet_wrap(~ food_type)

food_type_plot
```

## 1.3 Supermarket graph

Last, I present a line graph that shows the proportion of sensory and action features per supermarket and food type.
```{r lines_supermarkets}
# get data
supermarket_summary <-
  summarySEwithin(
    data = study1,
    measurevar = "sensory_proportion",
    withinvars = c("food_type", "supermarket")
  )

# visualize
line_graph <-
  ggplot(
    supermarket_summary %>% 
      mutate(
        food_type = fct_recode(
          food_type,
          "Meat-based" = "meat_based",
          "Vegetarian" = "vegetarian",
          "Plant-based" = "plant_based"
        )
      ),
    aes(
      x = food_type,
      y = sensory_proportion,
      color = supermarket,
      group = supermarket,
    )
  ) +
  geom_line() +
  #geom_point(shape = "square") +
  xlab("Food Type") +
  ylab("Proportion of Sensory Features") +
  labs(group = "Supermarket", # otherwise I get two legends
       color = "Supermarket") +
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic" # change font
    )
  )

line_graph
```

Maybe a line graph isn't ideal, so I'll visualize that as a raincloud plot as well.
```{r rainclouds_supermarket}
# change factor levels for plot
study1 <-
  study1 %>% 
  mutate(
    supermarket_n = case_when(
      supermarket == "A" ~ 1,
      supermarket == "B" ~ 2,
      supermarket == "C" ~ 3,
      supermarket == "D" ~ 4
    ),
    food_type = recode(
      food_type,
      "meat_based" = "Meat-based",
      "vegetarian" = "Vegetarian",
      "plant_based" = "Plant-based"
    )
  )

supermarket_summary <-
  supermarket_summary %>% 
    mutate(
    supermarket_n = case_when(
      supermarket == "A" ~ 1,
      supermarket == "B" ~ 2,
      supermarket == "C" ~ 3,
      supermarket == "D" ~ 4
    ),
    food_type = recode(
      food_type,
      "meat_based" = "Meat-based",
      "vegetarian" = "Vegetarian",
      "plant_based" = "Plant-based"
    )
  )


rc_supermarket <-
  ggplot(
    study1,
    aes(
      x = supermarket,
      y = sensory_proportion,
      fill = supermarket,
    )
  ) +
  geom_flat_violin(position = position_nudge(x = .1, # move the cloud a bit to the right
                                             y = 0),
                   adjust = 1.5,
                   trim = FALSE,
                   alpha = 0.5,
                   color = NA) +
  geom_point(aes(x = as.numeric(supermarket_n)-.2, # transfer the factor to number so that I can move the rain to the left with the -
                 color = supermarket,
                 y = sensory_proportion),
             position = position_jitter(width = .1),
             size = 1.2,
             alpha = 0.4) +
  geom_point( # the mean
    data = supermarket_summary,
    aes(
      x = as.numeric(supermarket_n)-.25, # same as above, moving it a bit to the left to be right between cloud and rain
      y = sensory_proportion,
      color = supermarket
    ),
    position = position_nudge(.25),
    size = 3
  ) +
  geom_errorbar( # error bars
    data = supermarket_summary,
    aes(
      x = as.numeric(supermarket_n)-.25,
      y = sensory_proportion,
      ymin = sensory_proportion - ci,
      ymax = sensory_proportion + ci,
      color = supermarket
    ),
    position = position_nudge(.25),
    width = 0.00,
    size = 0.8
  ) +
  ylim(c(-.002,1.002)) + # to not cut off points with jitter
  xlab("Supermarket") +
  ylab("Proportion of Sensory Features") +
  labs(fill = "Supermarket", # otherwise I get two legends
       color = "Supermarket") +
  scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic", # change font
      size = 22
    ),
    legend.title = element_text(
      size = 22
    ),
    legend.text = element_text(
      size = 22
    ),
    strip.background.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  facet_wrap(~ food_type)

rc_supermarket
```

Still pretty messy, I'll try means with CIs faceted by food type.
```{r point_graph_food_types}
point_graph_food <-
  ggplot(
    supermarket_summary,
    aes(
      x = food_type,
      y = sensory_proportion,
      color = supermarket
    )
  ) +
  geom_point(
    size = 3,
    position = position_dodge(width = 0.5)
  ) +
  geom_errorbar(
    aes(
      ymin = sensory_proportion - ci,
      ymax = sensory_proportion + ci
    ),
    size = 0.8,
    width = 0.00,
    position = position_dodge(width = 0.5)
  ) +
  coord_cartesian(ylim = c(0, 0.3)) +
  xlab("Food Type") +
  ylab("Proportion of Sensory Features") +
  labs(color = "Supermarket") +
  scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic", # change font
      size = 22
    ),
    legend.title = element_text(
      size = 22
    ),
    legend.text = element_text(
      size = 22
    ),
    axis.text.x = element_text(
      size = 16
    ),
    axis.ticks.x = element_blank()
  )

point_graph_food
```

I'll also try out the other way around.
```{r point_graph_supermarkets}
point_graph_supermarkets <-
  ggplot(
    supermarket_summary,
    aes(
      x = supermarket,
      y = sensory_proportion,
      color = food_type
    )
  ) +
  geom_point(
    size = 3,
    position = position_dodge(width = 0.5)
  ) +
  geom_errorbar(
    aes(
      ymin = sensory_proportion - ci,
      ymax = sensory_proportion + ci
    ),
    size = 0.8,
    width = 0.00,
    position = position_dodge(width = 0.5)
  ) +
  coord_cartesian(ylim = c(0, 0.3)) +
  xlab("Supermarket") +
  ylab("Proportion of Sensory Features") +
  labs(color = "Food Type") +
  scale_color_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  scale_fill_manual(values = c("#009E73", "#D55E00", "#0072B2", "#CC79A7")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic" # change font
    )
  )
```


# 2. Study 2

## 2.1 Load and prepare data

Next, I load the final data files from Study 2.
I saved those at the end of the analysis report (`analysis_report_study2.Rmd`).
```{r factors_to_numbers_study2}
study2 <- read_csv(here("data", "study2", "analysis_file.csv"))
attractiveness <- read_csv(here("data", "study2", "attractiveness.csv"))
simulations <- read_csv(here("data", "study2", "simulations.csv"))

# reintroduce factors
study2 <- 
  study2 %>% 
  mutate_at(
    vars(pp, measure, food_type, label_type),
    list(~ as.factor(.))
  )
```

Now on to producing the 2x2 raincloud plot.
I recode the factor just like above.
```{r numeric_factor_study2}
study2 <-
  study2 %>% 
  mutate(
    label_type_n = if_else(label_type == "control", 1, 2),
    label_type_n = as.factor(label_type_n)
  )
```

## 2.2 Raincloud plots

For means with 95%CI, I also need the summary statistics with within-subject standard errors.
I'll get those with the `Rmisc` package.
Note that I aggregate per participant first to make the CIs comparable to a repeated-measures ANOVA.
```{r get_summary_study2}
# aggregate first
aggregated <- 
  study2 %>% 
  group_by(pp, label_type, food_type, measure) %>% 
  summarize(
    rating = mean(rating, na.rm = TRUE)
  )

# then get summary stats
summary_stats <- summarySEwithin(
  data = aggregated,
  measurevar = "rating",
  withinvars = c("label_type", "food_type", "measure"),
  idvar = "pp") %>% 
    mutate( # add the same variable as above
      label_type_n = if_else(label_type == "control", 1, 2),
      food_type = recode( # purely cosmetic so that ggplot displays the levels with capital letters
        food_type,
        "plant_based" = "Plant-based",
        "meat_based" = "Meat-based"
      ),
      measure = recode(
        measure,
        "attractiveness" = "Attractiveness",
        "simulations" = "Simulations"
      )
    )
```

Next, the raincloud plot.
```{r make_it_rain}
rc_plot_study2 <-
  ggplot(
    study2 %>% 
      mutate(
        food_type = recode( # rename factor levels
          food_type,
          "plant_based" = "Plant-based",
          "meat_based" = "Meat-based"
        ),
        measure = recode(
          measure,
          "attractiveness" = "Attractiveness",
          "simulations" = "Simulations"
        )
      ),
    aes(
      x = label_type_n,
      y = rating,
      fill = food_type,
    )
  ) +
  geom_flat_violin(position = position_nudge(x = 0.05, # move the cloud a bit to the right
                                             y = 0),
                   adjust = 1.5,
                   trim = FALSE,
                   alpha = 0.5,
                   color = NA) +
  geom_point(aes(x = as.numeric(label_type_n)-.2, # transfer the factor to number so that I can move the rain to the left with the -.2
                 color = food_type,
                 y = rating),
             position = position_jitter(width = .15),
             size = 1.2,
             alpha = 0.4) +
  geom_point( # the mean
    data = summary_stats,
    aes(
      x = as.numeric(label_type_n)-.25, # same as above, moving it a bit to the left to be right between cloud and rain
      y = rating,
      color = food_type
    ),
    position = position_nudge(.25),
    size = 3
  ) +
  geom_errorbar( # error bars
    data = summary_stats,
    aes(
      x = as.numeric(label_type_n)-.25,
      y = rating,
      ymin = rating - 2,
      ymax = rating + 2,
      color = food_type
    ),
    position = position_nudge(.25),
    width = 0.00,
    size = 0.8
  ) +
  geom_line( # line connecting the means per group
    data = summary_stats,
    aes(
      x = as.numeric(label_type_n),
      y = rating,
      group = food_type,
      color = food_type
    ),
    linetype = 1,
    size = 1.1
  ) +
  ylim(c(0,100)) +
  ylab("Rating") +
  xlab("Description Type") +
  labs(fill = "Food Type", # otherwise I get two legends
       color = "Food Type") +
  scale_x_discrete(labels = c('Control','Enhanced')) + # rename the x axis after transforming it to numeric earlier
  scale_color_manual(values = c("#009E73", "#D55E00")) +
  scale_fill_manual(values = c("#009E73", "#D55E00")) +
  theme_cowplot() +
  theme(
    text = element_text(
      family="Century Gothic", # change font
      size = 28
    ), 
    strip.background.x = element_blank(),
    axis.text.x = element_text(
      size = 22
    ),
    legend.title = element_text(
      size = 22
    ),
    legend.text = element_text(
      size = 22
    )
  ) + 
  facet_grid(. ~ measure)

rc_plot_study2
```

## 2.3 Interaction plots

Next, I plot the interactions between categorical and numerical variables.
Contrary to the raincloud plots, where I plotted the raw data, the interaction plots are meant to illustrate the simple slope analyses.
When plotting the raw data with a fitted line, this line will be fitted with `lm`.
Usually I prefer this "raw" approach, but it's not entirely accurate to represent the simple slope analyses we conducted based on mixed-effects models.
```{r interaction_plots_simple}
# with simple slope and lm method (without SEs, because they'd be wrong)
ggplot(study2 %>% 
         filter(measure == "attractiveness"),
       aes(
         x = change_diet, 
         y = rating,
         color = label_type
        )
      ) + 
  geom_smooth(
    method = "lm",
    se = FALSE
    ) + 
  geom_point(alpha = 0.2) + 
  ylim(0, 100) +
  scale_color_manual(values = c("#009E73", "#D55E00")) +
  theme_cowplot()
```

Therefore, I will fit the model-based means and the CIs based on the model-estimated SEs.

As far as I know, there's no agreed-upon way to do this.
The `effects` package has a built-in graph that models the fitted outcome for different levels of the predictor, including model-based SEs.

I prefer to use `ggplot2`, so I'll get 5000 values of the predictor plus their fit and store them as a tibble.
Got the idea from [here](https://www.r-bloggers.com/plotting-mixed-effects-model-results-with-effects-package/).
I wrote all these steps into functions, see beginning of the script.

To get the estimates from the models, I first need to import the models that I saved at the end of the analysis report.
```{r interaction_model_mixed_effects}
# get models
load(here("plots", "models", "models.RData"))

# the plot with the effects package
plot(
  effect("change_diet_s:food_type", 
         h4_attr),
         ci.style = "bands",
  multiline = TRUE)
```

Plots for the interaction of intention to reduce eating meat and food type.
```{r change_diet_food_type_interaction}
# get the data set
h4_effects <-
  get_effects(
    "change_diet_s:food_type",
    h4_attr,
    5000,
    "food_type"
  )

# plot data
h4_plot <-
  interaction_plot(
    h4_effects,
    "change_diet_s",
    "fit",
    "food_type",
    "Attractiveness",
    "Intention to Reduce Eating Meat",
    "Food Type"
    )

h4_plot
```

Plots for the interaction of frequency of eating meat and food type.
```{r meat_frequency_food_type_interaction}
# get the data set
exp_meat_effects <- 
  get_effects(
    "meat_per_week_s:food_type",
    exp_attr_meat,
    5000,
    "food_type"
  )

# plot data
exp_meat_plot <-
  interaction_plot(
    exp_meat_effects,
    "meat_per_week_s",
    "fit",
    "food_type",
    "Attractiveness",
    "Frequency of Eating Meat",
    "Food Type"
    )

exp_meat_plot
```

Plots for the interaction of frequency of eating meat and label type for plant-based foods.
```{r meat_frequency_label_type_interaction}
# get the data set
exp_meat_label_effects <- 
  get_effects(
    "meat_per_week_s:label_type",
    exp_attr_meat_labels,
    5000,
    "label_type"
  )

# plot data
exp_meat_label_plot <-
  interaction_plot(
    exp_meat_label_effects,
    "meat_per_week_s",
    "fit",
    "label_type",
    "Rating",
    "Frequency of Eating Meat",
    "Description Type"
    )

exp_meat_label_plot
```

# 3. Save plots
Note: I don't save them because they are too large for Github.
```{r save_plots, eval=F}
# study 1 supermarkets
tiff(here("plots", "figure1.tiff"), width = 879*8, height = 632*5, units = "px", res = 600)
point_graph_food
dev.off()

# study1 sensory
ggsave(here("plots", "figure2.tiff"),
       plot = sensory_plot,
       dpi = 600)

# study1 consumption
ggsave(here("plots", "study1_consumption.tiff"),
       plot = consumption_plot,
       dpi = 600)

# study1 non-consumption
ggsave(here("plots", "study1_non_consumption.tiff"),
       plot = non_consumption_plot,
       dpi = 600)

# study1 situation independent
ggsave(here("plots", "study1_situation_independent.tiff"),
       plot = situation_independent_plot,
       dpi = 600)

# study1 by food type
tiff(here("plots", "figure3.tiff"), width = 879*8, height = 632*5, units = "px", res = 600)
food_type_plot
dev.off()

# study 2 raincloud
tiff(here("plots", "figure4.tiff"), width = 879*8, height = 632*8, units = "px", res = 600)
rc_plot_study2
dev.off()

# study 2 interaction h4
ggsave(here("plots", "figure5.tiff"),
       plot = h4_plot,
       dpi = 600)

# study 2 exploratory plot 1
ggsave(here("plots", "figure6.tiff"),
       plot = exp_meat_plot,
       dpi = 600)

# study 2 exploratory plot 2
ggsave(here("plots", "figure7.tiff"),
       plot = exp_meat_label_plot,
       dpi = 600)
```

